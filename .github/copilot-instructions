ğŸ“š Peaked Circuits in a Nutshell
â€œPeaked circuitsâ€ are pre-constructed quantum circuits with a non-uniform distribution of measurement outcomes. They are designed in a way that one particular bitstring has a higher probability than others, e.g. O(1) as opposed to exponentially small amplitude. 

They were introduced by Scott Aaronson as a way to achieve verifiable quantum advantage. Carefully crafted peaked circuits look like random circuits  - like the one used by Google in their benchmark that would take supercomputers septillion=10Â²âµ years to replicate. However, unlike random circuits - peaked circuits are much easier to verify: all you need to do is to run them on a quantum computer and verify you get the correct hidden bitstring!

Try to crack these circuits in .qasm2 format - they grow in difficulty and points ğŸ“ˆ

Crack = find the peak bitstring that has the max amplitude and stands out from the rest of amplitudes! 

To submit the peak bitstring use the submission tab ğŸ‘†
About bit-order: We are using little endian convention, e.g. qubit-0 is the rightmost bit in the final bitstring (like in qiskit convention). But you donâ€™t have to worry about it - we will count both the peak bitstring and its reverse as correct. In case you got the order wrong - you will see that info as a warning in the submission result.
You can use the below script to load .qasm2 files in qiskit ğŸ‘‡
from qiskit import QuantumCircuit

qc = QuantumCircuit.from_qasm_file('P1.qasm')

